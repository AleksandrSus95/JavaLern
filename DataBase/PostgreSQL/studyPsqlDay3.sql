--Создадим таблицы фильмов и актеров для 3го дня изучения SQL
--
--Создадим таблицу жанров фильмов
CREATE TABLE genres (
    name text UNIQUE,
    position INTEGER
);
--Если не было установлено расширение то установить
CREATE EXTENSION IF NOT EXISTS "cube" WITH SCHEMA pg_catalog;
--Создадим таблицу фильмов
CREATE TABLE movies (
    movie_id SERIAL PRIMARY KEY,
    title text,
    genre cube
);

--Создадим таблицу актеров
CREATE TABLE actors (
    actor_id SERIAL PRIMARY KEY,
    name text
);

--Создадим таблицу в каких филмах снимался актер
CREATE TABLE movies_actors (
    movie_id INTEGER REFERENCES movies NOT NULL,
    actor_id INTEGER REFERENCES actors NOT NULL,
    UNIQUE (movie_id, actor_id)
);

--Создадим индексы для ускорения поиска
CREATE INDEX movies_actors_movie_id ON movies_actors (movie_id);
CREATE INDEX movies_actors_actor_id ON movies_actors (actor_id);
CREATE INDEX movies_genres_cube ON movies USING gist (genre);

--Простейшие виды текстового поиска - это операторы LIKE и ILIKE присутствуют во всех реализация СУБД SQL
--LIKE - производит текстовый поиск БЕЗ учета регистра
--ILIKE - производит поиск с учетом регистра
--Сопоставляют значения в столбцах с указанным образцом.
--Используют 2 метасимвола при поиске:
--"%" - сопоставляется с произвольным числом символов и
--"_" - сопоставляетс одним символом

--Регулярные выражения
--являются более мощьным видом текстового поиска, синтаксис регулярных выражений в SQL соответствует стандарту POSIX (по большей части)
--в общем такие же регулярки как и везде.
--Пример работы с регулярным выражением
--напишем запрос для поиска событий из таблицы events в title которого отсутсвует слово Day
SELECT * FROM events
WHERE title !~* '.+day$';
--Обрати ВНИМАНИЕ НА !~*
--! - знак отрицания, т.е мы ищем не подходящие под регулярку тайтлы
--~ - знак того что работаем с регулярным выражением если поставить = то он будет сравнивать как строку
--* - знак того что нам все равно на регистр верхний или нижний, если его убрать то Day не подойдет под указанную регулярку.

--Полнотекстовый поиск
--Для полнотекстового поиска используется оператор @@
--Например нам надо найти события в тайтле которых есть слово day и party
--Запрос будет выглядеть следующим образом
SELECT * FROM events
WHERE title @@ 'day & party';
--Такой запрос найдет события в которых присутсвуют обюа этих слова
--
--Оператор @@ преобразует поле тайтл в тип tsvector а сам запрос в tsquery
--Тип данных tsvector - представляет собой строку в виде массива (или вектора) лексем, которые сравниваются со строкой
--указанной в запросе
--Тип данных tsquery - представляет запрос на некотором естественном языке например на английском или французком. Языку
--соответствует его словарь.
--Эквивалентный запрос:
SELECT * FROM events
WHERE to_tsvector(title) @@ to_tsquery('english', 'day & party');

--Посмотрим как разбивается запрос на компоненты вектор и запрос
SELECT to_tsvector('A hard Day''s Night'),
       to_tsquery('english','day & party');

--ОБРАТИТЬ ВНИМАНИЕ!!! tsvector при поиске игнорирует простые слова такие как артикль a. В частности артикль a называется
--стоп словом, как правило искать по ним не имеет смысла так как они встречаются очень часто.

--Список стоп слов для конкретного языка можно посмотреть
--cat 'pg_config --sharedir'/tsearch_data/english.stop (Но предварительно надо найти где лежит этот файлик)

--При желании можно удалить стоп слово из списка или использовать другой словарь
--Например словарь simple просто разобьети строку на слова и преобразует их в нижний регистр
SELECT to_tsvector('english', 'A Hard Day''s Night');
SELECT to_tsvector('simple', 'A Hard Day''s Night');
--При использовании словаря simple можно найти любое событие в котором встречается лексема а.

--Чтобы посмотреть какие языки установлены используй команду \dFd
--
--Сам по себе полнотекстовый поиск работает достаточно медленно, в процессе такого поиска происходит сканирование все таблицы
--чтобы ускорить этот процесс можно воспользоваться индексированием лексем.
--Для этого надо создать индекс, например:
CREATE INDEX index_name ON table_name
USING gin(to_tsvector('english', column_name));
--Индекс по  значениям лексем имеет тип Generalized Inverted Index (GIN) - этот тип встроен в ядро. Является стандартной структурой
--данный применяемой для полнотекстового поиска
--Чтобы воспользоваться индексом для ускорения поиска необходимо при селекте указать язык, т.к при запросе постгрес не знает
--какой язык используется и применять этот индекс не будет. (Указывается во фразе WHERE)
--Пример:
SELECT *
FROM table_name
WHERE to_tsvector('english', title) @@ 'night & day';