**Класс Thread и интерфейс Runnable**  
Поток - средство которое помогает организовать одновременное выполнение нескольких задач,
каждой в в независимом потоке. Потоки представляют собой экземпляр классов, каждый из которых
запускается и функционирует самомстоятельно, автономно (или относительно автономно) от главного
потока выполнения программы.  
Три способа создания и апуска потока:  
- на основе расширения класса Thread
- реализация интерфейса Runnable
- реализация интерфейса Callable  

При реализации интерфейса Runnable необходимо переопределить один абстрактный метод **run()**  

**Жизненный цикл потока**  
Поток может находится в одном из состояний статического вложенно класса-перечисления
Thread.State:
- NEW - поток создан но еще не запущен
- RUNNABLE - поток выполняется
- BLOCKED - поток блокирован
- WAITING - поток ждет окончания работы другого потока
- TIMED_WAITING - поток некоторое время ждет окончания другого потока или просто в ожидании истечения времени
- TERMINATED - поток завершен  

Поток переходит в состояние "Неработоспособоный" в режиме ожидания WAITING вызовом методов
join(), wait() или методов ввода/вывода, которые предполагают задержку.  
Для задержки потока на некоторое время можно перевести его в режим ожидания по времени, 
с помощью петодов sleep(long millis), join(long timeout), wait(long timeout).  
Вернуть потоку работосособность после вызова метода wait() - методами notify() и notifyAll()/
Когда поток просыпается ему необходимо изменить состояние монитора объекта на котором проходило
ожидание, для этого поток переводят в состояние BLOCKED и только после этого поток возвращается
в работоспособное состояние.  
Поток переходит в состояние TERMINATED если вызваны методы interrupt() или stop() **(некорректное завершение
без высвобождения ресурсов)** или 
метод **run()** завершил выполнение **(что является корректным завершением)**  

**Interface Callable**  
- представляет поток с возвращаемым значением вызывающему потоку. Определяет одим мето `V call() throws Exception`  
  в код реализации которого и стоит поместить поставленную задачу.  

Результат выполнения мб получен после окончания выполнения через экземпляр класса Future<V>, методом V get()
или V get(long timeout, TimeUnit unit). **Эти методы останавливают выполнение потока, по этому вызывать их стоит
после окончания выполнения потока Callable**  
Перед извлечением результатов можно проверить завершилась ли задача успешно с помощью методов 
`isDone() or isCancelled()`.  

Вспомогательный класс для управления заданиями (потоками Callable) **Executor -> ExecutorService -> ScheduledExecutorService**  
- `execute(Runnable task)` - Запускает традиционные потоки
- `submit(Callable<T> task) or submit(Runnable task)` - запускает потоки как с возвращаемым значением так и традиционные
- `invokeAll(Collection<? extends Callable<T>>)` - запуск нескольких потоков с возвращаемым значением.
- `shutdown()` - прекращает действие самого исполнителя после, завершения выполнения запущенных им ранее заданий,
  не даст запустить новые, сгенерирует исключение если будет попытка запуска нового задания **RejectExecutionException**
- `shutdownNow()` - остановит работу сервисами и удалит все запущеныне на объекте задачи-потоки.  
- `boolean awaitTermination(long timeout, TimeUnit unit)` - останавливает поток в котором вызван, и по истечении времени возвращает
  true, если все потоки запущенные объектом ExecutorService завершили работу, или false если нет.  

**Статические методы класса Executors**
- `newSingleThreadExecutor()` - позволяет запускать только один поток
- `newFixedThreadPool(int numThreads)` - позволяет запускать количество поток не более чем указано в numThreads
- `newScheduledPool()` - запуск потока по расписани  

**Механизм Fork/Join**  
Планировщик ForkJoinPool распределяет задания между запущенными потоками. Реализуется стратегия разделя и властвуй.
Больщая задача делится на более мелкие, которые в свою очередь делятся на еще более мелкие, рекурсивно, пока не будет получена
маленькая задача. Затем весь пул мелких задач выполняется параллельно на процессорных ядрах. Разельтаты задач объеденяются
при получении общего результата. Все потоки созданные ForkJoinPool запущены как потоки демоны.  
Примерный алгоритм стратегии:  
```
if(размер задачи < порогового значения) {  
  1. Решить задачу напрямую.
}else{  
  1. Разбить задачу на подзадачи
  2. Рекурсивно решить каждую задачу
  3. Объеденить результаты
}  
```
Абстрактный класс ForkJoinTask представляет основные final методы:
- `ForkJoinTask<V> fork()` - отправляет задчу для асинхронного выполнения. Этот метод возвращяет текущий объект ForkJoinTask,
  а вызывающий поток продолжает работать
- `V join()` - ожидает выполнения задачи и возвращает рузельтат
- `V invoke()` - объеденяет fork() and join() в одном вызове. Он запускает задачу, ожидает ее выполнения и возвращает результат.
- `invokeAll()` - статический метод для запуска нескольких задач одновременно

Класс RecursiveTask(V) используется для задач которые возвращают значения и по своей сути аналогичен интерфейсу Callable<E> с
его методами call(). Опредяет абстрактный метод protected V compute(), не предназначенный для внешних вызовов.  

**Потоки демоны**
Потоки демоны работают в фоновом режиме, занимаются фоновыми задачами, обслуживают другие потоки.
Чтобы запустить поток как поток-демон достаточно воспользоваться методом setDaemon(boolean value), а метод boolean isDaemon()
позволяет определить является ли поток демоном.
Базовое свойство потока-демона заключается в возможности основного потока приложения main() завершить выполнение потока
демона (в отличии от обычных потоков) с окончанием кода метода main(), не обращая внимание на то что поток-демон еще работает.

