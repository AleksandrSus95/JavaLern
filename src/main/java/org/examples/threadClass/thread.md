**Класс Thread и интерфейс Runnable**  
Поток - средство которое помогает организовать одновременное выполнение нескольких задач,
каждой в в независимом потоке. Потоки представляют собой экземпляр классов, каждый из которых
запускается и функционирует самомстоятельно, автономно (или относительно автономно) от главного
потока выполнения программы.  
Три способа создания и апуска потока:  
- на основе расширения класса Thread
- реализация интерфейса Runnable
- реализация интерфейса Callable  

При реализации интерфейса Runnable необходимо переопределить один абстрактный метод **run()**  

**Жизненный цикл потока**  
Поток может находится в одном из состояний статического вложенно класса-перечисления
Thread.State:
- NEW - поток создан но еще не запущен
- RUNNABLE - поток выполняется
- BLOCKED - поток блокирован
- WAITING - поток ждет окончания работы другого потока
- TIMED_WAITING - поток некоторое время ждет окончания другого потока или просто в ожидании истечения времени
- TERMINATED - поток завершен  

Поток переходит в состояние "Неработоспособоный" в режиме ожидания WAITING вызовом методов
join(), wait() или методов ввода/вывода, которые предполагают задержку.  
Для задержки потока на некоторое время можно перевести его в режим ожидания по времени, 
с помощью петодов sleep(long millis), join(long timeout), wait(long timeout).  
Вернуть потоку работосособность после вызова метода wait() - методами notify() и notifyAll()/
Когда поток просыпается ему необходимо изменить состояние монитора объекта на котором проходило
ожидание, для этого поток переводят в состояние BLOCKED и только после этого поток возвращается
в работоспособное состояние.  
Поток переходит в состояние TERMINATED если вызваны методы interrupt() или stop() **(некорректное завершение
без высвобождения ресурсов)** или 
метод **run()** завершил выполнение **(что является корректным завершением)**  

**Interface Callable**  
- представляет поток с возвращаемым значением вызывающему потоку. Определяет одим мето `V call() throws Exception`  
  в код реализации которого и стоит поместить поставленную задачу.  

Результат выполнения мб получен после окончания выполнения через экземпляр класса Future<V>, методом V get()
или V get(long timeout, TimeUnit unit). **Эти методы останавливают выполнение потока, по этому вызывать их стоит
после окончания выполнения потока Callable**  
Перед извлечением результатов можно проверить завершилась ли задача успешно с помощью методов 
`isDone() or isCancelled()`.  

Вспомогательный класс для управления заданиями (потоками Callable) **Executor -> ExecutorService -> ScheduledExecutorService**  
- `execute(Runnable task)` - Запускает традиционные потоки
- `submit(Callable<T> task) or submit(Runnable task)` - запускает потоки как с возвращаемым значением так и традиционные
- `invokeAll(Collection<? extends Callable<T>>)` - запуск нескольких потоков с возвращаемым значением.
- `shutdown()` - прекращает действие самого исполнителя после, завершения выполнения запущенных им ранее заданий,
  не даст запустить новые, сгенерирует исключение если будет попытка запуска нового задания **RejectExecutionException**
- `shutdownNow()` - остановит работу сервисами и удалит все запущеныне на объекте задачи-потоки.  
- `boolean awaitTermination(long timeout, TimeUnit unit)` - останавливает поток в котором вызван, и по истечении времени возвращает
  true, если все потоки запущенные объектом ExecutorService завершили работу, или false если нет.  

**Статические методы класса Executors**
- `newSingleThreadExecutor()` - позволяет запускать только один поток
- `newFixedThreadPool(int numThreads)` - позволяет запускать количество поток не более чем указано в numThreads
- `newScheduledPool()` - запуск потока по расписани